import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { ScanService } from '../../../services/scan.service';

export interface VulnerabilityDetails {
  _id: string;
  escaneo_id: string;
  tipo_id: {
    _id: string;
    nombre: string;
    descripcion: string;
  };
  nivel_severidad_id: {
    _id: string;
    nombre: string;
    nivel: number;
    color: string;
  };
  parametro_afectado?: string;
  url_afectada?: string;
  descripcion?: string;
  sugerencia?: string;
  referencia?: string;
  scan?: {
    alias: string;
    url: string;
    fecha_inicio: string;
  };
}

@Component({
  selector: 'app-vulnerability-details',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './vulnerability-details.html',
  styleUrls: ['./vulnerability-details.scss']
})
export class VulnerabilityDetailsComponent implements OnInit {
  vulnerabilityId: string = '';
  scanId: string = '';
  vulnerability: VulnerabilityDetails | null = null;
  loading: boolean = true;
  error: string | null = null;

  // Mitigation suggestions
  mitigationSteps: string[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private scanService: ScanService
  ) {}

  ngOnInit(): void {
    this.vulnerabilityId = this.route.snapshot.paramMap.get('vulnId') || '';
    this.scanId = this.route.snapshot.paramMap.get('scanId') || '';
    
    if (this.vulnerabilityId && this.scanId) {
      this.loadVulnerabilityDetails();
    }
  }

  loadVulnerabilityDetails(): void {
    this.loading = true;
    this.error = null;

    // Get the full scan report to find the specific vulnerability
    this.scanService.getScanReport(this.scanId).subscribe({
      next: (response: any) => {
        if (response.success && response.report) {
          // Find the specific vulnerability
          const vuln = response.report.vulnerabilidades.find(
            (v: any) => v._id === this.vulnerabilityId
          );

          if (vuln) {
            this.vulnerability = {
              ...vuln,
              scan: {
                alias: response.report.scan.alias,
                url: response.report.scan.url,
                fecha_inicio: response.report.scan.fecha_inicio
              }
            };
            this.parseMitigationSteps();
          } else {
            this.error = 'Vulnerabilidad no encontrada';
          }
        }
        this.loading = false;
      },
      error: (err) => {
        console.error('Error loading vulnerability details:', err);
        this.error = 'Error al cargar los detalles de la vulnerabilidad';
        this.loading = false;
      }
    });
  }

  parseMitigationSteps(): void {
    if (this.vulnerability?.sugerencia) {
      // Split suggestions into steps (assuming they're numbered or separated by periods/newlines)
      const suggestions = this.vulnerability.sugerencia
        .split(/\d+\.\s*|\n/)
        .filter(s => s.trim().length > 0)
        .map(s => s.trim());
      
      this.mitigationSteps = suggestions.length > 0 ? suggestions : [this.vulnerability.sugerencia];
    } else {
      // Default mitigation steps based on vulnerability type
      this.mitigationSteps = this.getDefaultMitigationSteps();
    }
  }

  getDefaultMitigationSteps(): string[] {
    const vulnType = this.vulnerability?.tipo_id?.nombre?.toLowerCase();
    
    if (vulnType === 'sqli' || vulnType?.includes('sql')) {
      return [
        'Implementar consultas parametrizadas (prepared statements) en lugar de concatenar directamente las entradas del usuario en las consultas SQL.',
        'Aplicar validación de entrada estricta, permitiendo solo caracteres esperados y rechazando caracteres especiales de SQL.',
        'Utilizar un ORM (Object-Relational Mapping) que maneje automáticamente la sanitización de las consultas.',
        'Implementar el principio de mínimo privilegio en la base de datos, asegurando que el usuario de la aplicación solo tenga los permisos necesarios.',
        'Considerar la implementación de un WAF (Web Application Firewall) como capa adicional de protección.'
      ];
    } else if (vulnType === 'xss') {
      return [
        'Escapar todos los datos de entrada del usuario antes de mostrarlos en el HTML.',
        'Implementar Content Security Policy (CSP) headers para prevenir la ejecución de scripts no autorizados.',
        'Utilizar frameworks que automáticamente escapan las salidas (como Angular, React, Vue).',
        'Validar y sanitizar todas las entradas del usuario en el lado del servidor.',
        'Usar HTTPOnly y Secure flags en las cookies para prevenir el robo de sesiones.'
      ];
    } else {
      return [
        'Implementar validación de entrada estricta para todos los datos del usuario.',
        'Aplicar el principio de defensa en profundidad con múltiples capas de seguridad.',
        'Mantener todas las dependencias y frameworks actualizados.',
        'Realizar auditorías de seguridad periódicas.',
        'Implementar un programa de divulgación responsable de vulnerabilidades.'
      ];
    }
  }

  goBack(): void {
    this.router.navigate(['/dashboard/scans', this.scanId, 'report']);
  }

  getSeverityClass(severity: string): string {
    const sev = severity?.toLowerCase();
    if (sev === 'crítica' || sev === 'critica') return 'severity-critical';
    if (sev === 'alta') return 'severity-high';
    if (sev === 'media') return 'severity-medium';
    if (sev === 'baja') return 'severity-low';
    return '';
  }

  getSeverityLabel(severity: string): string {
    return severity || 'Desconocida';
  }

  openReference(url: string | undefined): void {
    if (url) {
      window.open(url, '_blank');
    }
  }

  formatDate(dateString: string | undefined): string {
    if (!dateString) return 'N/A';
    
    return new Date(dateString).toLocaleString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
}
